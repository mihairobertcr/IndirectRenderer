#include "../IndirectData.hlsl"

#pragma kernel CSMain

#define THREAD_GROUP_SIZE_X 128
#define THREAD_GROUP_SIZE_Y 1
#define THREAD_GROUP_SIZE_Z 1

StructuredBuffer<float3> _Positions;
StructuredBuffer<float3> _Scales;
StructuredBuffer<float3> _Rotations;

RWStructuredBuffer<Indirect2x2Matrix> _InstanceMatrixRows01;
RWStructuredBuffer<Indirect2x2Matrix> _InstanceMatrixRows23;
RWStructuredBuffer<Indirect2x2Matrix> _InstanceMatrixRows45;

float4x4 RotationMatrix(float3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return float4x4(
        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,
        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,
        oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,
        0, 0, 0, 1.0);
}

// https://forum.unity.com/threads/incorrect-normals-on-after-rotating-instances-graphics-drawmeshinstancedindirect.503232/#post-3277479
float4x4 Inverse(float4x4 input)
{
    #define Minor(a,b,c) determinant(float3x3(input.a, input.b, input.c))
	
    float4x4 cofactors = float4x4(
         Minor(_22_23_24, _32_33_34, _42_43_44),
        -Minor(_21_23_24, _31_33_34, _41_43_44),
         Minor(_21_22_24, _31_32_34, _41_42_44),
        -Minor(_21_22_23, _31_32_33, _41_42_43),
	
        -Minor(_12_13_14, _32_33_34, _42_43_44),
         Minor(_11_13_14, _31_33_34, _41_43_44),
        -Minor(_11_12_14, _31_32_34, _41_42_44),
         Minor(_11_12_13, _31_32_33, _41_42_43),
	
         Minor(_12_13_14, _22_23_24, _42_43_44),
        -Minor(_11_13_14, _21_23_24, _41_43_44),
         Minor(_11_12_14, _21_22_24, _41_42_44),
        -Minor(_11_12_13, _21_22_23, _41_42_43),
	
        -Minor(_12_13_14, _22_23_24, _32_33_34),
         Minor(_11_13_14, _21_23_24, _31_33_34),
        -Minor(_11_12_14, _21_22_24, _31_32_34),
         Minor(_11_12_13, _21_22_23, _31_32_33)
    );
    #undef Minor
    return transpose(cofactors) / determinant(input);
}

[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
inline void CSMain (
        in uint3 dispatchThreadId : SV_DispatchThreadID, // DispatchThreadID  = dot(GroupID, numthreads) + GroupThreadId;
        in uint  groupIndex       : SV_GroupIndex,       // GroupIndex = unique index of a thread inside a group
        in uint3 groupId          : SV_GroupID,          // GroupID = index for each dimension inside a ThreadGroupCount 
        in uint3 groupThreadId    : SV_GroupThreadID)    // GroupThreadId = indices for each dimension inside a group of the current thread
{
    uint threadID = dispatchThreadId.x;

    float3 position = _Positions[threadID];
    float3 scale    = _Scales[threadID];
    float3 rotation = _Rotations[threadID];
    
    float4x4 xRotationMatrix = RotationMatrix(float3(1, 0, 0), radians(rotation.x));
    float4x4 yRotationMatrix = RotationMatrix(float3(0, 1, 0), radians(rotation.y));
    float4x4 zRotationMatrix = RotationMatrix(float3(0, 0, 1), radians(rotation.z));
    float4x4 rotationMatrix  = mul(yRotationMatrix, mul(zRotationMatrix, xRotationMatrix));

    float4x4 translation =
    {
        scale.x, 0, 0, position.x,
        0, scale.y, 0, position.y,
        0, 0, scale.z, position.z,
        0, 0, 0, 1
    };
	
    float4x4 objectToWorld = mul(translation, rotationMatrix);
    float4x4 worldToObject = Inverse(objectToWorld);
    
    Indirect2x2Matrix rows01;
    Indirect2x2Matrix rows23;
    Indirect2x2Matrix rows45;
    
    rows01.FirstRow  = objectToWorld[0];
    rows01.SecondRow = objectToWorld[1];
    rows23.FirstRow  = objectToWorld[2];
    
    rows23.SecondRow = worldToObject[0];
    rows45.FirstRow  = worldToObject[1];
    rows45.SecondRow = worldToObject[2];
    
    _InstanceMatrixRows01[threadID] = rows01;
    _InstanceMatrixRows23[threadID] = rows23;
    _InstanceMatrixRows45[threadID] = rows45;
}