#include "../IndirectData.hlsl"

#pragma kernel CSMain
#pragma kernel SplitArguments;

#define THREAD_GROUP_SIZE_X 128
#define THREAD_GROUP_SIZE_Y   1
#define THREAD_GROUP_SIZE_Z   1

cbuffer CB
{
    uint _NumberOfDrawCalls;
}

StructuredBuffer<SortingData> _SortingData;
StructuredBuffer<Matrix2x2> _MatrixRows01;
StructuredBuffer<Matrix2x2> _MatrixRows23;
StructuredBuffer<Matrix2x2> _MatrixRows45;

StructuredBuffer<uint> _PredicatesInput;
StructuredBuffer<uint> _GroupSums;
StructuredBuffer<uint> _ScannedPredicates;
RWStructuredBuffer<uint> _DrawCallsDataOutput;
RWStructuredBuffer<Matrix2x2> _CulledMatrixRows01;
RWStructuredBuffer<Matrix2x2> _CulledMatrixRows23;
RWStructuredBuffer<Matrix2x2> _CulledMatrixRows45;

// Split args
RWStructuredBuffer<uint> _LodArgs0;
RWStructuredBuffer<uint> _LodArgs1;
RWStructuredBuffer<uint> _LodArgs2;

// Based on Parallel Prefix Sum (Scan) with CUDA by Mark Harris
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
inline void CSMain (
        in uint3 _dispatchThreadId : SV_DispatchThreadID, // DispatchThreadID = dot(GroupID, numthreads) + GroupThreadId;
        in uint  _groupIndex       : SV_GroupIndex,       // GroupIndex = unique index of a thread inside a group
        in uint3 _groupId          : SV_GroupID,          // GroupID = index for each dimension inside a ThreadGroupCount 
        in uint3 _groupThreadId    : SV_GroupThreadID)    // GroupThreadId = indices for each dimension inside a group of the current thread
{
    uint threadId = _dispatchThreadId.x;
    uint groupId  = _groupId.x;
    uint groupSum = _groupId.x > 0 ? _GroupSums[_groupId.x] : 0;

    // Scatter results
    if (_PredicatesInput[threadId] == 1)
    {
        uint instanceDataOutIndex = _ScannedPredicates[threadId] + groupSum;
        uint drawInstanceIndex = _SortingData[threadId].DrawCallInstanceIndex & 0xFFFF;
        
        _CulledMatrixRows01[instanceDataOutIndex] = _MatrixRows01[drawInstanceIndex];
        _CulledMatrixRows23[instanceDataOutIndex] = _MatrixRows23[drawInstanceIndex];
        _CulledMatrixRows45[instanceDataOutIndex] = _MatrixRows45[drawInstanceIndex];
    }
    
    if ((threadId == 0) * (groupId == 0))
    {
        // Patch up the visible instance counts per prop type
        for (uint k = 1; k < _NumberOfDrawCalls; k++)
        {
            _DrawCallsDataOutput[k * 5 + 4] =
                _DrawCallsDataOutput[(k - 1) * 5 + 4] +   // Previous prop type offset 
                _DrawCallsDataOutput[(k - 1) * 5 + 1];    // Previous prop type number of instances
        }
    }
}

[numthreads(1, 1, 1)]
inline void SplitArguments(
        in uint3 _dispatchThreadId : SV_DispatchThreadID, // DispatchThreadID = dot(GroupID, numthreads) + GroupThreadId;
        in uint  _groupIndex       : SV_GroupIndex,       // GroupIndex = unique index of a thread inside a group
        in uint3 _groupId          : SV_GroupID,          // GroupID = index for each dimension inside a ThreadGroupCount 
        in uint3 _groupThreadId    : SV_GroupThreadID)    // GroupThreadId = indices for each dimension inside a group of the current thread
{
    _LodArgs0[1] = _DrawCallsDataOutput[1];
    _LodArgs0[4] = _DrawCallsDataOutput[4];
    
    _LodArgs1[1] = _DrawCallsDataOutput[6];
    _LodArgs1[4] = _DrawCallsDataOutput[9];

    _LodArgs2[1] = _DrawCallsDataOutput[11];
    _LodArgs2[4] = _DrawCallsDataOutput[14];
}